using System.Diagnostics;
using System.Globalization;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using Application = System.Windows.Forms.Application;

// This namespace contains the device drivers classes for
// barcode readers.
namespace BarcodeApp
{
    ///<summary>
    ///This class contains the implementation for a generic barcode
    ///reader.
    ///
    ///Many barcode readers can use this driver because they can be
    ///configured to use a very simple protocol, based on optional
    ///header character(s), data and on mandatory trailer
    ///character(s).
    ///
    ///The typical sequence is [header] {data} {trailer}
    ///
    ///If header is defined any character read before the header is
    ///discarded, if not defined any character read is considered
    ///part of the message. The message is terminated by the trailer
    ///character(s).
    ///
    ///The driver can use barcode readers attached to serial port or
    ///to the keyboard port.
    ///
    ///
    ///An example of INI file line is:
    ///
    ///BARCODE Type=<B>Generic</B> <B>Port</B>=COM1:9600,n,8,1 <B>Header</B>=2
    ///<B>Trailer</B>=13,10
    ///
    ///This device is attached on port 1, uses the STX as header and
    ///the CR and LF as trailer.
    ///
    ///
    ///<B>Port</B> can be a COM port specification or<B> Keyboard</B>
    ///when using the keyboard port.
    ///
    ///<B>Header</B> (optional) is a comma delimited list of the
    ///chars code that are sent before the data is sent.
    ///
    ///<B>Trailer</B> (mandatory) is a comma delimited list of the
    ///chars that are sent before after the data.
    ///</summary>
    public class GenericReader : IMessageFilter
    {

        private readonly byte[] headerBytes;
        private readonly byte[] trailerBytes;

        private readonly int[] headerScancodes;
        private readonly int[] trailerScancodes;

        /// <summary>
        /// This field is used when a reader is not able to send a trailer.
        /// In this situation data is complete when a certain length is reached.
        /// If 0, no length check is made
        /// </summary>
        private readonly int trackLength;

        /// <summary>
        /// When > 0, in no character arrives within the specified number of milliseconds
        /// the barcode is considered as terminated and the received character buffer is sent.
        /// Use this parameter when a barcode has no trailer
        /// </summary>
        private readonly int trailerTimeout;

        /// <summary>
        /// Timer used to implement the trailerTimeout. This timer has to run only once after it has been activated
        /// and not at regular interval.
        /// </summary>
        private readonly System.Threading.Timer trailerTimeoutTimer;
       
        /// <summary>
        /// When false, events generated by keyboard keypresses have to be ignored
        /// </summary>
        private bool enabled;

        /// <summary>
        /// Force all char read to upper
        /// </summary>
        private readonly bool forceToUpper;

        /// <summary>
        /// When true, the shift key status is managed intercepting the shift down and up.
        /// Activate the parameter in the INI line with ManageShift=true
        /// events
        /// </summary>
        private readonly bool manageShiftKeys;

        /// <summary>
        /// The keyboard interface uses a state machine. This enum contains the different states.
        /// </summary>
        private enum KeybStatus
        {
            /// <summary>
            /// No header byte was received yet.
            /// </summary>
            Idle,

            /// <summary>
            /// The first header byte was received. Wait for next bytes.
            /// </summary>
            ReadingHeader,

            /// <summary>
            /// Data is arriving and are appended in the buffer until the trailer comes.
            /// </summary>
            ReadingData,

            /// <summary>
            /// The first trailer byte was received. Wait for next bytes.
            /// </summary>
            ReadingTrailer
        }

        private KeybStatus keybState;

        /// <summary>
        /// The number of header bytes read. Used when trailer is longer that one byte.
        /// </summary>
        private int headerByte;

        /// <summary>
        /// The number of trailer bytes read. Used when header is longer that one byte.
        /// </summary>
        private int trailerByte;

        /// <summary>
        /// The timestamp of the last keypress.
        /// </summary>
        private long lastKeyTimestamp;

        /// <summary>
        /// The string that contains the keypress saved so far
        /// </summary>
        private string keysBuffer = "";

        /// <summary>
        /// This event is called when a barcode is read.
        /// This is initialized only when the class behaves as a barcode
        /// </summary>
        public event BarcodeReaderEvent BarcodeEvent;
        
        ///<summary>
        ///Class constructor.
        ///</summary>
        ///<param name="param">The INI file line with reader parameters.</param>
        /// <exception cref="ApplicationException">In case of errors an exception is thrown
        /// and the object is not created.</exception>
        public GenericReader(IniValue param)
        {
            string[] byteList;
            
            // Intercept application messages and capture WM_KEYDOWN messages
            //Application.AddMessageFilter(this);
            KeyboardHookHandler.RegisterHandler(ManageKeyboardHook);

            keybState = KeybStatus.Idle;
            lastKeyTimestamp = DateTime.Now.Ticks;
            Console.WriteLine("Barcode reader generic created on keyboard port");

            string bytes = param.ValueOf("Header");
            if (!string.IsNullOrEmpty(bytes))
            {
                byteList = bytes.Split(',');
                headerBytes = new byte[byteList.Length];
                for (int i = 0; i < byteList.Length; i++)
                {
                    headerBytes[i] = byte.Parse(byteList[i]);
                }
            }

            bytes = param.ValueOf("Trailer");
            if (!string.IsNullOrEmpty(bytes))
            {
                byteList = bytes.Split(',');
                trailerBytes = new byte[byteList.Length];
                for (int i = 0; i < byteList.Length; i++)
                {
                    trailerBytes[i] = byte.Parse(byteList[i]);
                }
            }           

            // Manage the timer that decides that the barcode is terminated when trailer chars are not defined
            trailerTimeout = Convert.ToInt32(param.ValueOf("TrailerTimeout", "0"));
            if (trailerTimeout > 0)
            {
                trailerTimeoutTimer = new System.Threading.Timer(timeoutTimer_Callback, null, Timeout.Infinite, Timeout.Infinite);
            }                               

            bytes = param.ValueOf("ForceToUpper");
            if (!string.IsNullOrEmpty(bytes))
            {
                try
                {
                    forceToUpper = Convert.ToBoolean(bytes);
                }
                catch (Exception)
                {
                    Console.WriteLine("The ForceToUpper parameter is invalid.");
                }
            }

            manageShiftKeys = param.ValueOf("ManageShift", "false").ToLower() == "true";

            if (trailerBytes == null && trailerScancodes == null && trackLength == 0 && trailerTimeout == 0)
            {
                throw new ApplicationException("Trailer is not defined");
            }

            if (headerBytes != null && headerScancodes != null)
            {
                throw new ApplicationException("Cannot specify both Header and ScancodeHeader parameters.\nOnly one is permitted");
            }

            if (trailerBytes != null && trailerScancodes != null)
            {
                throw new ApplicationException("Cannot specify both Trailer and ScancodeTrailer parameters.\nOnly one is permitted");
            }
        }

        ///<summary>
        ///Class destructor. Closes the device and ports before
        ///destroying the object.
        ///</summary>
        ~GenericReader()
        {
            Close();
        }

        /// <summary>
        /// Close the device and release all the resources.
        /// </summary>
        public void Close()
        {            
            Application.RemoveMessageFilter(this);
        }

        /// <summary>
        /// Enable the reader.
        /// </summary>
        public void Enable()
        {
            enabled = true;
        }

        ///<summary>
        ///Disable the reader.
        ///</summary>
        public void Disable()
        {
            enabled = false;
        }

        /// <summary>
        /// Clear the received chars buffer.
        /// </summary>
        public bool Eject()
        {
            return true;
        }


        /// <summary>
        /// The shift status is handled if the parameter ManageShift is set to true
        /// </summary>
        private bool shiftDown = false;

        /// <summary>
        /// This event is raised when a key event is raised at operating-system level. This is active only if the
        /// flag InterceptAllKeys was set to true and will make the default PreFilterMessage not to be called.
        /// The event is therefore forwarded, if the result is true the key was managed by the barcode reader and
        /// will not be forwarded to the rest of the application (/operating system)
        /// </summary>
        /// <param name="messageRaised"></param>
        /// <returns></returns>
        private bool ManageKeyboardHook(Message messageRaised)
        {
            return PreFilterMessage(ref messageRaised);
        }

        /// <summary>
        /// Intercept the application messages and filter the WM_KEYDOWN messages.
        /// </summary>
        /// <param name="m">The window message.</param>
        /// <returns>true if the procedure processed the message, so it must be not be propagated.
        /// false if the the procedure didn't process the message.</returns>
        public bool PreFilterMessage(ref Message m)
        {
            bool processed = false;

            if (m.Msg == Win32.WM_KEYDOWN || m.Msg == Win32.WM_SYSKEYDOWN)
            {
                KeyboardKey key = new KeyboardKey(ref m, shiftDown);

                if (manageShiftKeys)
                {
                    if (key.Scancode == 42 || key.Scancode == 54)
                    {
                        shiftDown = true;
                    }
                }

                // if last key was read more than a second ago, return to idle status.
                if ((DateTime.Now.Ticks - lastKeyTimestamp) > (1000 * TimeSpan.TicksPerMillisecond))
                {
                    keybState = KeybStatus.Idle;
                }

                lastKeyTimestamp = DateTime.Now.Ticks;

                try
                {
                    if (keybState == KeybStatus.Idle)
                    {
                        Console.WriteLine("Keyboard status={0}", keybState);
                        // If no header is present
                        if (headerBytes == null && headerScancodes == null)
                        {
                            // clean the buffer;
                            keysBuffer = "";
                            // Change the status.
                            keybState = KeybStatus.ReadingData;
                            // The byte will be added later
                        }
                        else if ((headerBytes != null && key.ConvertedChar == (char)headerBytes[0]) ||
                          (headerScancodes != null && key.Scancode == headerScancodes[0]))
                        {
                            // Change the status.
                            keybState = KeybStatus.ReadingHeader;
                            headerByte = 0;
                        }
                    }

                    if (keybState == KeybStatus.ReadingHeader)
                    {
                        Console.WriteLine("Keyboard status={0}, headerByte={1}", keybState, headerByte);
                        if ((headerBytes != null && key.ConvertedChar == (char)headerBytes[headerByte]) ||
                          (headerScancodes != null && key.Scancode == headerScancodes[headerByte]))
                        {
                            headerByte++;
                            if ((headerBytes != null && headerByte == headerBytes.Length) ||
                              (headerScancodes != null && headerByte == headerScancodes.Length))
                            {
                                // header byte is read, now go in read data status
                                keysBuffer = "";
                                keybState = KeybStatus.ReadingData;
                            }

                            processed = true;
                        }
                    }

                    if (keybState == KeybStatus.ReadingData && !processed)
                    {
                        Console.WriteLine("Keyboard status={0}", keybState);
                        if ((trailerBytes != null && key.ConvertedChar == (char)trailerBytes[0]) ||
                          (trailerScancodes != null && key.Scancode == trailerScancodes[0]))
                        {
                            keybState = KeybStatus.ReadingTrailer;
                            trailerByte = 0;
                        }
                        else if (key.ConvertedChar != 0)
                        {
                            keysBuffer += key.ConvertedChar;

                            // If a fixed lenght is read, generate the data read event immediately
                            if (keysBuffer.Length == trackLength)
                            {
                                GenerateEvent(keysBuffer);
                            }
                            else if (trailerTimeout > 0)
                            {
                                // Reset the moment the timer will be executed
                                trailerTimeoutTimer.Change(trailerTimeout, Timeout.Infinite);
                            }
                        }

                        processed = true;
                    }

                    if (keybState == KeybStatus.ReadingTrailer)
                    {
                        Console.WriteLine("Keyboard status={0}, trailer byte={1}", keybState, trailerByte);
                        if ((trailerBytes != null && key.ConvertedChar == (char)trailerBytes[trailerByte]) ||
                          (trailerScancodes != null && key.Scancode == trailerScancodes[trailerByte]))
                        {
                            trailerByte++;
                            if ((trailerBytes != null && trailerByte == trailerBytes.Length) ||
                              (trailerScancodes != null && trailerByte == trailerScancodes.Length))
                            {
                                GenerateEvent(keysBuffer);
                            }

                            processed = true;
                        }
                    }
                }
                catch (Exception e)
                {
                    Console.WriteLine("Error while reading from keyboard device, resetting status. {0}", e.Message);
                    keybState = KeybStatus.Idle;
                }
            }
            else if (m.Msg == Win32.WM_KEYUP || m.Msg == Win32.WM_SYSKEYUP)
            {
                KeyboardKey key = new KeyboardKey(ref m);

                if (manageShiftKeys)
                {
                    if (key.Scancode == 42 || key.Scancode == 54)
                    {
                        shiftDown = false;
                    }
                }
            }

            return processed;
        }

        /// <summary>
        /// This procedure is called when the trailer timeout timer is expired.
        /// </summary>
        private void timeoutTimer_Callback(object state)
        {
            trailerTimeoutTimer.Change(Timeout.Infinite, Timeout.Infinite);
            if (keybState == KeybStatus.ReadingData && keysBuffer != "")
            {
                Console.WriteLine("Barcode read timeout, using current buffer.");
                GenerateEvent(keysBuffer);
            }
        }

        /// <summary>
        /// Throw the card or barcode read event
        /// </summary>
        private void GenerateEvent(string buffer)
        {
            if (!enabled)
            {
                return;
            }

            if (forceToUpper)
            {
                buffer = buffer.ToUpper();
            }

            // All data read. Send the event and go in idle mode.
            Console.WriteLine("Generic reader: '{0}'", buffer);
            keybState = KeybStatus.Idle;

            // Call the delegate of the proper peripheral type
            BarcodeEvent?.Invoke(buffer);
            Console.WriteLine("read bc: " + buffer);
        }               
    }

    public delegate void BarcodeReaderEvent(string barcode);
}
